const std = @import("std");
const dialect = @import("dialect.zig");

pub const Span = struct {
    start: usize,
    end: usize,

    pub const global: Span = .{ .start = 0, .end = 0 };

    pub fn fromOffsets(start: usize, end: usize) Span {
        return .{ .start = start, .end = end };
    }

    pub fn merge(a: Span, b: Span) Span {
        return .{
            .start = @min(a.start, b.start),
            .end = @max(a.end, b.end),
        };
    }

    pub fn containsOffset(self: Span, offset: usize) bool {
        return offset >= self.start and offset < self.end;
    }

    pub fn containsSpan(self: Span, other: Span) bool {
        return other.start >= self.start and other.end <= self.end;
    }

    pub fn sliceFrom(self: Span, source: []const u8) []const u8 {
        return source[self.start..self.end];
    }

    pub fn startAt(self: Span, start: usize) Span {
        return .{ .start = start, .end = self.end };
    }

    pub fn endAt(self: Span, end: usize) Span {
        return .{ .start = self.start, .end = end };
    }
};

pub const Token = struct {
    tag: Tag,
    lexeme: []const u8,
    span: Span,
};

pub const Tag = enum {
    identifier,
    quoted_identifier,
    local_variable,
    string_literal,
    number_literal,
    comment_line,

    illegal,
    eof,

    sharp,
    mod,
    period,
    semicolon,
    left_paren,
    right_paren,
    plus,
    minus,
    comma,
    less_than,
    greater_than,
    less_than_equal,
    greater_than_equal,
    equal,
    not_equal_bang,
    not_equal_arrow,
    plus_equal,
    minus_equal,
    multiply_equal,
    divide_equal,
    mod_equal,
    caret_equal,
    pipe_equal,
    pipe,
    ampersand_equal,
    ampersand,
    asterisk,
    forward_slash,
    tilde,
    double_colon, // postgres

    // Keywords
    kw_with,
    kw_exec,
    kw_select,
    kw_distinct,
    kw_top,
    kw_limit, // postgres, mysql, sqlite
    kw_from,
    kw_where,
    kw_insert,
    kw_update,
    kw_delete,
    kw_create,
    kw_alter,
    kw_drop,
    kw_declare,
    kw_set,
    kw_cast,
    kw_as,
    kw_asc,
    kw_desc,
    kw_and_,
    kw_or_,
    kw_order,
    kw_group,
    kw_by,
    kw_over,
    kw_partition,
    kw_range,
    kw_offset,
    kw_fetch,
    kw_row,
    kw_rows,
    kw_first,
    kw_next,
    kw_only,
    kw_percent,
    kw_ties,
    kw_full,
    kw_left,
    kw_right,
    kw_inner,
    kw_outer,
    kw_join,
    kw_on,
    kw_having,
    kw_between,
    kw_following,
    kw_preceding,
    kw_unbounded,
    kw_current,
    kw_not,
    kw_like,
    kw_all,
    kw_exists,
    kw_any,
    kw_in,
    kw_some,
    kw_int,
    kw_bigint,
    kw_tinyint,
    kw_smallint,
    kw_bit,
    kw_float,
    kw_real,
    kw_date,
    kw_datetime,
    kw_time,
    kw_decimal,
    kw_numeric,
    kw_varchar,
    kw_is,
    kw_null,
    kw_true,
    kw_false,
    kw_case,
    kw_when,
    kw_then,
    kw_else,
    kw_end,
    kw_filter,
    kw_window,
    // postgres
    kw_returning,
    kw_ilike,
    kw_similar,
    kw_distinct_on,
    kw_lateral,
    kw_recursive,
    kw_boolean,
    kw_text,
    kw_uuid,
    kw_json,
    kw_jsonb,
    kw_serial,
    kw_bigserial,
    kw_enum,
    // sqlite
    kw_replace,
    kw_conflict,
    kw_abort,
    kw_fail,
    kw_ignore,
    kw_restrict,
    kw_without,
    kw_integer,
    kw_blob,

    pub fn toString(tag: Tag) []const u8 {
        return switch (tag) {
            .identifier => "identifier",
            .quoted_identifier => "quoted_identifier",
            .local_variable => "local_variable",
            .string_literal => "string_literal",
            .number_literal => "number_literal",
            .comment_line => "comment_line",
            .illegal => "illegal",
            .eof => "eof",
            .sharp => "sharp",
            .mod => "mod",
            .period => "period",
            .semicolon => "semicolon",
            .left_paren => "left_paren",
            .right_paren => "right_paren",
            .plus => "plus",
            .minus => "minus",
            .comma => "comma",
            .less_than => "less_than",
            .greater_than => "greater_than",
            .less_than_equal => "less_than_equal",
            .greater_than_equal => "greater_than_equal",
            .equal => "equal",
            .not_equal_bang => "not_equal_bang",
            .not_equal_arrow => "not_equal_arrow",
            .plus_equal => "plus_equal",
            .minus_equal => "minus_equal",
            .multiply_equal => "multiply_equal",
            .divide_equal => "divide_equal",
            .mod_equal => "mod_equal",
            .caret_equal => "caret_equal",
            .pipe_equal => "pipe_equal",
            .pipe => "pipe",
            .ampersand_equal => "ampersand_equal",
            .ampersand => "ampersand",
            .asterisk => "asterisk",
            .forward_slash => "forward_slash",
            .tilde => "tilde",
            .double_colon => "double_colon",
            .kw_with => "kw_with",
            .kw_exec => "kw_exec",
            .kw_select => "kw_select",
            .kw_distinct => "kw_distinct",
            .kw_top => "kw_top",
            .kw_from => "kw_from",
            .kw_where => "kw_where",
            .kw_insert => "kw_insert",
            .kw_update => "kw_update",
            .kw_delete => "kw_delete",
            .kw_create => "kw_create",
            .kw_alter => "kw_alter",
            .kw_drop => "kw_drop",
            .kw_declare => "kw_declare",
            .kw_set => "kw_set",
            .kw_cast => "kw_cast",
            .kw_as => "kw_as",
            .kw_asc => "kw_asc",
            .kw_desc => "kw_desc",
            .kw_and_ => "kw_and",
            .kw_or_ => "kw_or",
            .kw_order => "kw_order",
            .kw_group => "kw_group",
            .kw_by => "kw_by",
            .kw_over => "kw_over",
            .kw_partition => "kw_partition",
            .kw_range => "kw_range",
            .kw_offset => "kw_offset",
            .kw_fetch => "kw_fetch",
            .kw_row => "kw_row",
            .kw_rows => "kw_rows",
            .kw_first => "kw_first",
            .kw_next => "kw_next",
            .kw_only => "kw_only",
            .kw_percent => "kw_percent",
            .kw_ties => "kw_ties",
            .kw_full => "kw_full",
            .kw_left => "kw_left",
            .kw_right => "kw_right",
            .kw_inner => "kw_inner",
            .kw_outer => "kw_outer",
            .kw_join => "kw_join",
            .kw_on => "kw_on",
            .kw_having => "kw_having",
            .kw_between => "kw_between",
            .kw_following => "kw_following",
            .kw_preceding => "kw_preceding",
            .kw_unbounded => "kw_unbounded",
            .kw_current => "kw_current",
            .kw_not => "kw_not",
            .kw_like => "kw_like",
            .kw_all => "kw_all",
            .kw_exists => "kw_exists",
            .kw_any => "kw_any",
            .kw_in => "kw_in",
            .kw_some => "kw_some",
            .kw_int => "kw_int",
            .kw_bigint => "kw_bigint",
            .kw_tinyint => "kw_tinyint",
            .kw_smallint => "kw_smallint",
            .kw_bit => "kw_bit",
            .kw_float => "kw_float",
            .kw_real => "kw_real",
            .kw_date => "kw_date",
            .kw_datetime => "kw_datetime",
            .kw_time => "kw_time",
            .kw_decimal => "kw_decimal",
            .kw_numeric => "kw_numeric",
            .kw_varchar => "kw_varchar",
            .kw_is => "kw_is",
            .kw_null => "kw_null",
            .kw_true => "kw_true",
            .kw_false => "kw_false",
            .kw_case => "kw_case",
            .kw_when => "kw_when",
            .kw_then => "kw_then",
            .kw_else => "kw_else",
            .kw_end => "kw_end",
            .kw_returning => "kw_returning",
            .kw_ilike => "kw_ilike",
            .kw_similar => "kw_similar",
            .kw_distinct_on => "kw_distinct_on",
            .kw_lateral => "kw_lateral",
            .kw_recursive => "kw_recursive",
            .kw_boolean => "kw_boolean",
            .kw_text => "kw_text",
            .kw_uuid => "kw_uuid",
            .kw_json => "kw_json",
            .kw_jsonb => "kw_jsonb",
            .kw_serial => "kw_serial",
            .kw_bigserial => "kw_bigserial",
            .kw_enum => "kw_enum",
            .kw_replace => "kw_replace",
            .kw_conflict => "kw_conflict",
            .kw_abort => "kw_abort",
            .kw_fail => "kw_fail",
            .kw_ignore => "kw_ignore",
            .kw_restrict => "kw_restrict",
            .kw_without => "kw_without",
            .kw_integer => "kw_integer",
            .kw_blob => "kw_blob",
        };
    }
};

// keyword types
const map = std.StaticStringMap(Tag).initComptime(.{
    .{ "with", .kw_with },
    .{ "exec", .kw_exec },
    .{ "select", .kw_select },
    .{ "distinct", .kw_distinct },
    .{ "top", .kw_top },
    .{ "from", .kw_from },
    .{ "where", .kw_where },
    .{ "insert", .kw_insert },
    .{ "update", .kw_update },
    .{ "delete", .kw_delete },
    .{ "create", .kw_create },
    .{ "alter", .kw_alter },
    .{ "drop", .kw_drop },
    .{ "declare", .kw_declare },
    .{ "set", .kw_set },
    .{ "cast", .kw_cast },
    .{ "as", .kw_as },
    .{ "asc", .kw_asc },
    .{ "desc", .kw_desc },
    .{ "and", .kw_and_ },
    .{ "or", .kw_or_ },
    .{ "order", .kw_order },
    .{ "group", .kw_group },
    .{ "by", .kw_by },
    .{ "over", .kw_over },
    .{ "partition", .kw_partition },
    .{ "range", .kw_range },
    .{ "offset", .kw_offset },
    .{ "fetch", .kw_fetch },
    .{ "row", .kw_row },
    .{ "rows", .kw_rows },
    .{ "first", .kw_first },
    .{ "next", .kw_next },
    .{ "only", .kw_only },
    .{ "percent", .kw_percent },
    .{ "ties", .kw_ties },
    .{ "full", .kw_full },
    .{ "left", .kw_left },
    .{ "right", .kw_right },
    .{ "inner", .kw_inner },
    .{ "outer", .kw_outer },
    .{ "join", .kw_join },
    .{ "on", .kw_on },
    .{ "having", .kw_having },
    .{ "between", .kw_between },
    .{ "following", .kw_following },
    .{ "preceding", .kw_preceding },
    .{ "unbounded", .kw_unbounded },
    .{ "current", .kw_current },
    .{ "not", .kw_not },
    .{ "like", .kw_like },
    .{ "all", .kw_all },
    .{ "exists", .kw_exists },
    .{ "any", .kw_any },
    .{ "in", .kw_in },
    .{ "some", .kw_some },
    .{ "int", .kw_int },
    .{ "bigint", .kw_bigint },
    .{ "tinyint", .kw_tinyint },
    .{ "smallint", .kw_smallint },
    .{ "bit", .kw_bit },
    .{ "float", .kw_float },
    .{ "real", .kw_real },
    .{ "date", .kw_date },
    .{ "datetime", .kw_datetime },
    .{ "time", .kw_time },
    .{ "decimal", .kw_decimal },
    .{ "numeric", .kw_numeric },
    .{ "varchar", .kw_varchar },
    .{ "is", .kw_is },
    .{ "null", .kw_null },
    .{ "true", .kw_true },
    .{ "false", .kw_false },
    .{ "case", .kw_case },
    .{ "when", .kw_when },
    .{ "then", .kw_then },
    .{ "else", .kw_else },
    .{ "end", .kw_end },
    .{ "returning", .kw_returning },
    .{ "ilike", .kw_ilike },
    .{ "similar", .kw_similar },
    .{ "distinct_on", .kw_distinct_on },
    .{ "lateral", .kw_lateral },
    .{ "recursive", .kw_recursive },
    .{ "boolean", .kw_boolean },
    .{ "text", .kw_text },
    .{ "uuid", .kw_uuid },
    .{ "json", .kw_json },
    .{ "jsonb", .kw_jsonb },
    .{ "serial", .kw_serial },
    .{ "bigserial", .kw_bigserial },
    .{ "enum", .kw_enum },
    .{ "replace", .kw_replace },
    .{ "conflict", .kw_conflict },
    .{ "abort", .kw_abort },
    .{ "fail", .kw_fail },
    .{ "ignore", .kw_ignore },
    .{ "restrict", .kw_restrict },
    .{ "without", .kw_without },
    .{ "integer", .kw_integer },
    .{ "blob", .kw_blob },
});

pub fn keyword(ident: []const u8, sql_dialect: dialect.Dialect) ?Tag {
    var buf = [_]u8{0} ** 20;
    if (ident.len >= buf.len) {
        return null;
    }
    const lower_ident = std.ascii.lowerString(&buf, ident);
    if (dialect.core_keywords.get(lower_ident)) |tag| {
        return tag;
    }

    return switch (sql_dialect) {
        .sqlserver => dialect.sqlserver_keywords.get(lower_ident),
        .sqlite => dialect.sqlite_keywords.get(lower_ident),
        .postgres => dialect.postgres_keywords.get(lower_ident),
    };
}
