const std = @import("std");
const token = @import("token.zig");

pub const Dialect = enum {
    postgres,
    sqlserver,
    sqlite,
};

pub const Features = struct {
    top: bool,
    limit: bool,
    returning: bool,
    apply: bool,
};

pub const Keyword = enum {
    with,
    exec,
    select,
    distinct,
    top,
    limit, // postgres, mysql, sqlite
    from,
    where,
    insert,
    update,
    delete,
    create,
    alter,
    drop,
    declare,
    set,
    cast,
    as,
    asc,
    desc,
    and_,
    or_,
    order,
    group,
    by,
    over,
    partition,
    range,
    offset,
    fetch,
    row,
    rows,
    first,
    next,
    only,
    percent,
    ties,
    full,
    left,
    right,
    inner,
    outer,
    join,
    on,
    having,
    between,
    following,
    preceding,
    unbounded,
    current,
    not,
    like,
    all,
    exists,
    any,
    in,
    some,
    int,
    bigint,
    tinyint,
    smallint,
    bit,
    float,
    real,
    date,
    datetime,
    time,
    decimal,
    numeric,
    varchar,
    is,
    null,
    true,
    false,
    case,
    when,
    then,
    else_,
    end,
    filter,
    window,
    // postgres
    returning,
    ilike,
    similar,
    distinct_on,
    lateral,
    recursive,
    boolean,
    text,
    uuid,
    json,
    jsonb,
    serial,
    bigserial,
    enum_,
    // sqlite
    replace,
    conflict,
    abort,
    fail,
    ignore,
    restrict,
    without,
    integer,
    blob,

    pub fn fromTokenTagKeyword(tag: token.Tag) ?Keyword {
        return switch (tag) {
            .kw_with => .with,
            .kw_exec => .exec,
            .kw_select => .select,
            .kw_distinct => .distinct,
            .kw_top => .top,
            .kw_limit => .limit,
            .kw_from => .from,
            .kw_where => .where,
            .kw_insert => .insert,
            .kw_update => .update,
            .kw_delete => .delete,
            .kw_create => .create,
            .kw_alter => .alter,
            .kw_drop => .drop,
            .kw_declare => .declare,
            .kw_set => .set,
            .kw_cast => .cast,
            .kw_as => .as,
            .kw_asc => .asc,
            .kw_desc => .desc,
            .kw_and_ => .and_,
            .kw_or_ => .or_,
            .kw_order => .order,
            .kw_group => .group,
            .kw_by => .by,
            .kw_over => .over,
            .kw_partition => .partition,
            .kw_range => .range,
            .kw_offset => .offset,
            .kw_fetch => .fetch,
            .kw_row => .row,
            .kw_rows => .rows,
            .kw_first => .first,
            .kw_next => .next,
            .kw_only => .only,
            .kw_percent => .percent,
            .kw_ties => .ties,
            .kw_full => .full,
            .kw_left => .left,
            .kw_right => .right,
            .kw_inner => .inner,
            .kw_outer => .outer,
            .kw_join => .join,
            .kw_on => .on,
            .kw_having => .having,
            .kw_between => .between,
            .kw_following => .following,
            .kw_preceding => .preceding,
            .kw_unbounded => .unbounded,
            .kw_current => .current,
            .kw_not => .not,
            .kw_like => .like,
            .kw_all => .all,
            .kw_exists => .exists,
            .kw_any => .any,
            .kw_in => .in,
            .kw_some => .some,
            .kw_int => .int,
            .kw_bigint => .bigint,
            .kw_tinyint => .tinyint,
            .kw_smallint => .smallint,
            .kw_bit => .bit,
            .kw_float => .float,
            .kw_real => .real,
            .kw_date => .date,
            .kw_datetime => .datetime,
            .kw_time => .time,
            .kw_decimal => .decimal,
            .kw_numeric => .numeric,
            .kw_varchar => .varchar,
            .kw_is => .is,
            .kw_null => .null,
            .kw_true => .true,
            .kw_false => .false,
            .kw_case => .case,
            .kw_when => .when,
            .kw_then => .then,
            .kw_else_ => .else_,
            .kw_end => .end,
            .kw_filter => .filter,
            .kw_window => .window,
            .kw_returning => .returning,
            .kw_ilike => .ilike,
            .kw_similar => .similar,
            .kw_distinct_on => .distinct_on,
            .kw_lateral => .lateral,
            .kw_recursive => .recursive,
            .kw_boolean => .boolean,
            .kw_text => .text,
            .kw_uuid => .uuid,
            .kw_json => .json,
            .kw_jsonb => .jsonb,
            .kw_serial => .serial,
            .kw_bigserial => .bigserial,
            .kw_enum_ => .enum_,
            .kw_replace => .replace,
            .kw_conflict => .conflict,
            .kw_abort => .abort,
            .kw_fail => .fail,
            .kw_ignore => .ignore,
            .kw_restrict => .restrict,
            .kw_without => .without,
            .kw_integer => .integer,
            .kw_blob => .blob,
            else => null,
        };
    }
};

pub const core_keywords = std.StaticStringMap(Keyword).initComptime(.{
    .{ "with", .with },
    .{ "select", .select },
    .{ "distinct", .distinct },
    .{ "from", .from },
    .{ "where", .where },
    .{ "group", .group },
    .{ "by", .by },
    .{ "order", .order },
    .{ "having", .having },
    .{ "between", .between },
    .{ "and", .and_ },
    .{ "or", .or_ },
    .{ "is", .is },
    .{ "in", .in },
    .{ "not", .not },
    .{ "like", .like },
    .{ "all", .all },
    .{ "exists", .exists },
    .{ "any", .any },
    .{ "some", .some },
    .{ "insert", .insert },
    .{ "update", .update },
    .{ "delete", .delete },
    .{ "create", .create },
    .{ "alter", .alter },
    .{ "drop", .drop },
    .{ "cast", .cast },
    .{ "as", .as },
    .{ "case", .case },
    .{ "when", .when },
    .{ "then", .then },
    .{ "else", .else_ },
    .{ "end", .end },
    .{ "asc", .asc },
    .{ "desc", .desc },
    .{ "over", .over },
    .{ "partition", .partition },
    .{ "range", .range },
    .{ "offset", .offset },
    .{ "fetch", .fetch },
    .{ "row", .row },
    .{ "rows", .rows },
    .{ "first", .first },
    .{ "next", .next },
    .{ "only", .only },
    .{ "percent", .percent },
    .{ "ties", .ties },
    .{ "full", .full },
    .{ "left", .left },
    .{ "right", .right },
    .{ "inner", .inner },
    .{ "outer", .outer },
    .{ "join", .join },
    .{ "on", .on },
    .{ "following", .following },
    .{ "preceding", .preceding },
    .{ "unbounded", .unbounded },
    .{ "current", .current },
    .{ "int", .int },
    .{ "bigint", .bigint },
    .{ "tinyint", .tinyint },
    .{ "smallint", .smallint },
    .{ "bit", .bit },
    .{ "float", .float },
    .{ "real", .real },
    .{ "date", .date },
    .{ "time", .time },
    .{ "decimal", .decimal },
    .{ "numeric", .numeric },
    .{ "varchar", .varchar },
    .{ "null", .null },
    .{ "true", .true },
    .{ "false", .false },
});

pub const postgres_keywords = std.StaticStringMap(Keyword).initComptime(.{
    .{ "returning", .returning },
    .{ "lateral", .lateral },
    .{ "recursive", .recursive },
    .{ "ilike", .ilike },
    .{ "similar", .similar },
    .{ "text", .text },
    .{ "uuid", .uuid },
    .{ "json", .json },
    .{ "jsonb", .jsonb },
    .{ "serial", .serial },
    .{ "bigserial", .bigserial },
    .{ "enum", .enum_ },
});

pub const sqlite_keywords = std.StaticStringMap(Keyword).initComptime(.{
    .{ "blob", .blob },
    .{ "integer", .integer },
    .{ "text", .text },
    .{ "datetime", .datetime },
    .{ "replace", .replace },
    .{ "conflict", .conflict },
    .{ "abort", .abort },
    .{ "fail", .fail },
    .{ "ignore", .ignore },
    .{ "restrict", .restrict },
    .{ "without", .without },
});

pub const sqlserver_keywords = std.StaticStringMap(Keyword).initComptime(.{
    .{ "exec", .exec },
    .{ "top", .top },
    .{ "declare", .declare },
    .{ "set", .set },
    .{ "percent", .percent },
    .{ "ties", .ties },
    .{ "bit", .bit },
    .{ "datetime", .datetime },
});

pub fn lookupKeyword(ident: []const u8, sql_dialect: Dialect) ?Keyword {
    var buf = [_]u8{0} ** 20;
    if (ident.len >= buf.len) {
        return null;
    }
    const lower_ident = std.ascii.lowerString(&buf, ident);
    if (core_keywords.get(lower_ident)) |keyword| {
        return keyword;
    }

    return switch (sql_dialect) {
        .sqlserver => sqlserver_keywords.get(lower_ident),
        .sqlite => sqlite_keywords.get(lower_ident),
        .postgres => postgres_keywords.get(lower_ident),
    };
}
